use chrono;
use csv;
use env_logger::Builder;
use log::LevelFilter;
use rayon;
use std::{
    env,
    fs::OpenOptions,
    io::{BufWriter, Write},
    path::PathBuf,
};
use structopt::StructOpt;

mod errors;
mod mirror;

use errors::Error;
use mirror::{Evaluation, Filter, Mirrors, MirrorsStatus, ToPacmanMirrorList};

#[derive(Debug, StructOpt)]
#[structopt(author, about)]
struct Options {
    /// Arch Linux mirrors status's data source
    #[structopt(
        short = "S",
        long = "source-url",
        default_value = "https://www.archlinux.org/mirrors/status/json/"
    )]
    source_url: String,

    /// Mirror list output file
    #[structopt(short = "o", long = "output-file", parse(from_os_str))]
    output_file: PathBuf,

    /// Limit the list to the n mirrors with the highest score.
    #[structopt(short = "m", long = "mirrors", default_value = "10")]
    mirrors: usize,

    /// The maximum number of threads to use when measure transfer rate
    #[structopt(short = "T", long = "threads", default_value = "5")]
    threads: usize,

    /// Statistics output file
    #[structopt(short = "s", long = "stats-file", parse(from_os_str))]
    stats_file: Option<PathBuf>,

    /// Increment verbosity level once per call
    /// [error, -v: warn, -vv: info, -vvv: debug, -vvvv: trace]
    #[structopt(short = "v", long = "verbose", parse(from_occurrences))]
    verbose: u8,
}

/// Save evaluated mirrors to mirrorlist file
#[allow(clippy::ptr_arg)]
fn write_mirror_list(path: &PathBuf, source_url: &str, mirrors: &Mirrors) -> errors::Result<()> {
    let now = chrono::Utc::now();

    let file = OpenOptions::new()
        .write(true)
        .create(true)
        .append(false)
        .open(path)?;
    let mut file = BufWriter::new(file);

    writeln!(&mut file, "#")?;
    writeln!(&mut file, "# /etc/pacman.d/mirrorlist")?;
    writeln!(&mut file, "#")?;
    writeln!(&mut file, "#")?;
    writeln!(&mut file, "# Arch Linux mirrorlist generated by pacman-mirrorup")?;
    writeln!(&mut file, "#")?;
    writeln!(
        &mut file,
        "# pacman-mirrorup: https://github.com/bpetlert/pacman-mirrorup"
    )?;
    writeln!(&mut file, "# source: {}", source_url)?;
    writeln!(&mut file, "# when: {}", now.to_rfc3339())?;
    writeln!(&mut file, "#")?;
    writeln!(&mut file)?;
    file.write_all(&mirrors.to_pacman_mirror_list().as_bytes())?;

    file.flush()?;
    Ok(())
}

/// Save evaluated mirrors to CSV file
#[allow(clippy::ptr_arg)]
fn write_stats(path: &PathBuf, mirrors: &Mirrors) -> errors::Result<()> {
    let file = OpenOptions::new()
        .write(true)
        .create(true)
        .append(false)
        .open(path)?;
    let mut wtr = csv::Writer::from_writer(file);
    for mirror in mirrors.iter() {
        wtr.serialize(mirror)?;
    }
    wtr.flush()?;
    Ok(())
}

fn main() -> errors::Result<()> {
    let options = Options::from_args();
    let log_level = match options.verbose {
        0 => LevelFilter::Error,
        1 => LevelFilter::Warn,
        2 => LevelFilter::Info,
        3 => LevelFilter::Debug,
        4 => LevelFilter::Trace,
        _ => LevelFilter::Trace,
    };
    Builder::new()
        .parse_filters(&env::var("MIRRORUP_LOG").unwrap_or_default())
        .format(|buf, record| writeln!(buf, "{}: {}", record.level(), record.args()))
        .filter(None, log_level)
        .init();

    if options.output_file.exists() {
        return Err(Error::file_already_exists(options.output_file));
    }

    if let Some(stats_file) = &options.stats_file {
        if stats_file.exists() {
            return Err(Error::file_already_exists(stats_file.to_owned()));
        }
    }

    rayon::ThreadPoolBuilder::new()
        .num_threads(options.threads)
        .build_global()
        .unwrap();

    let mirrors_status: MirrorsStatus = MirrorsStatus::from_online_json(&options.source_url)?;
    let mirrors: Mirrors = mirrors_status.best_synced_mirrors();
    let best_mirrors = mirrors.evaluate(options.mirrors);
    write_mirror_list(&options.output_file, &options.source_url, &best_mirrors)?;

    if let Some(stats_file) = &options.stats_file {
        write_stats(&stats_file, &best_mirrors)?;
    }

    Ok(())
}
